# 235. Lowest Common Ancestor of a Binary Search Tree

**Difficulty:** Medium  
**Topics:** Binary Search Tree, Tree, Depth-First Search

---

## Problem Statement

Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.

According to the definition of LCA on Wikipedia: "The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself)."

---

## Examples

### Example 1

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
```

### Example 2

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
```

### Example 3

```
Input: root = [2,1], p = 2, q = 1
Output: 2
```

---

## Constraints

- The number of nodes in the tree is in the range `[2, 10^5]`
- `-10^9 <= Node.val <= 10^9`
- All `Node.val` are unique
- `p != q`
- `p` and `q` will exist in the BST

---

## Approach 1: Recursive (BST Property)

### Intuition

The key insight is to leverage the BST property: all nodes in the left subtree are smaller, and all nodes in the right subtree are larger. If both `p` and `q` are smaller than the current node, the LCA must be in the left subtree. If both are larger, the LCA must be in the right subtree. Otherwise, the current node is the LCA.

### Algorithm

1. If both `p` and `q` are smaller than root, recurse on the left subtree
2. If both `p` and `q` are larger than root, recurse on the right subtree
3. Otherwise, the current node is the LCA (split point)

### Code

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return null;

        // Both nodes are in the left subtree
        if (root.val > p.val && root.val > q.val) {
            return lowestCommonAncestor(root.left, p, q);
        }

        // Both nodes are in the right subtree
        if (root.val < p.val && root.val < q.val) {
            return lowestCommonAncestor(root.right, p, q);
        }
        
        // Split point: one node is on the left, one is on the right (or one is the root itself)
        return root;
    }
}
```

### Complexity Analysis

- **Time Complexity:** O(h) where h is the height of the tree
  - In the worst case (skewed tree), h = n
  - In a balanced BST, h = log(n)
- **Space Complexity:** O(h) for the recursion stack

---

## Approach 2: Iterative (BST Property)

### Intuition

We can convert the recursive approach to an iterative one using a while loop. This eliminates the recursion stack overhead.

### Algorithm

1. Start from the root
2. While traversing, if both nodes are on the left, move left
3. If both nodes are on the right, move right
4. Otherwise, we've found the LCA

### Code

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        int small = Math.min(p.val, q.val);
        int large = Math.max(p.val, q.val);
        
        while (root != null) {
            if (root.val > large) {
                // Both p and q belong to the left subtree
                root = root.left;
            } else if (root.val < small) {
                // Both p and q belong to the right subtree
                root = root.right;
            } else {
                // Split point: small <= root.val <= large
                // This root is the LCA between p and q
                return root;
            }
        }
        
        return null;
    }
}
```

### Complexity Analysis

- **Time Complexity:** O(h) where h is the height of the tree
- **Space Complexity:** O(1) - no recursion stack needed

---

## Approach 3: Generic Binary Tree Approach (Not Optimal for BST)

### Intuition

This is a general approach that works for any binary tree, not just BST. It doesn't leverage the BST property, so it's less efficient for this specific problem.

### Algorithm

1. If the current node is null or matches either p or q, return it
2. Recursively search in left and right subtrees
3. If both subtrees return non-null, current node is the LCA
4. Otherwise, return whichever subtree found a node

### Code

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || p == root || root == q) return root;

        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        if (left != null && right != null) return root;
        return left != null ? left : right;
    }
}
```

### Complexity Analysis

- **Time Complexity:** O(n) - might visit all nodes
- **Space Complexity:** O(h) for the recursion stack

### Why Not Optimal?

This approach doesn't use the BST property, so it potentially searches both subtrees even when it's unnecessary.

---

## Comparison of Approaches

| Approach | Time Complexity | Space Complexity | Best For |
|----------|----------------|------------------|----------|
| Recursive (BST) | O(h) | O(h) | Clean, intuitive code |
| Iterative (BST) | O(h) | O(1) | **Best** - Optimal space |
| Generic Tree | O(n) | O(h) | General binary trees |

---

## Key Takeaways

1. **Always leverage BST properties** when dealing with BST problems
2. The LCA in a BST is the first node where the paths to p and q diverge
3. Iterative solutions can reduce space complexity by avoiding recursion
4. A node can be an ancestor of itself

---

## Related Problems

- 236. Lowest Common Ancestor of a Binary Tree
- 1644. Lowest Common Ancestor of a Binary Tree II
- 1650. Lowest Common Ancestor of a Binary Tree III
- 1676. Lowest Common Ancestor of a Binary Tree IV
