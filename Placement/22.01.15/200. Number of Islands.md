# LeetCode 200: Number of Islands

## Problem Information
- **LeetCode Number:** 200
- **Difficulty:** Medium
- **Problem Link:** [Number of Islands](https://leetcode.com/problems/number-of-islands/)

---

## Problem Statement

Given a 2D binary grid representing a map where '1's represent land and '0's represent water, return the number of islands, where an island is formed by connecting adjacent lands horizontally or vertically.

**Example 1:**
```
Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
```

**Example 2:**
```
Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3
```

**Constraints:**
- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` is `'0'` or `'1'`

---

## Visual Representation

![Number of Islands Example](https://assets.leetcode.com/uploads/2021/04/19/islands.jpg)

In the grid above, you can visualize islands as groups of connected '1's:
- Island detection requires exploring all four directions (up, down, left, right)
- Diagonal connections do NOT count
- Each '1' that starts a new search represents a new island

---

## Intuition

The key insight is recognizing this as a **graph traversal problem**. Each cell in the grid is a node, and adjacent land cells ('1's) are connected. An island is essentially a connected component in this graph.

**Core observations:**
1. When we find a '1', we've discovered an island
2. We need to explore all connected land cells to avoid counting the same island multiple times
3. After exploring an island completely, we should mark it as visited to prevent recounting
4. The total number of separate DFS/BFS calls equals the number of islands

---

## Approach 1: Brute Force (Nested Loops with Visited Matrix)

### Algorithm
```
1. Create a separate visited matrix to track explored cells
2. Iterate through each cell in the grid
3. When we find an unvisited '1':
   - Increment island counter
   - Use DFS/BFS to mark all connected land cells as visited
4. Return the island count
```

### Implementation (Java)
```java
class Solution {
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) return 0;
        
        int rows = grid.length;
        int cols = grid[0].length;
        boolean[][] visited = new boolean[rows][cols];
        int count = 0;
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == '1' && !visited[i][j]) {
                    dfs(grid, visited, i, j);
                    count++;
                }
            }
        }
        return count;
    }
    
    private void dfs(char[][] grid, boolean[][] visited, int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length 
            || grid[i][j] == '0' || visited[i][j]) {
            return;
        }
        
        visited[i][j] = true;
        dfs(grid, visited, i + 1, j); // down
        dfs(grid, visited, i - 1, j); // up
        dfs(grid, visited, i, j + 1); // right
        dfs(grid, visited, i, j - 1); // left
    }
}
```

**Time Complexity:** O(m × n) - We visit each cell once  
**Space Complexity:** O(m × n) - For the visited matrix and recursion stack

**Drawback:** Uses extra space for the visited matrix.

---

## Approach 2: Optimized Solution (In-place Modification)

### Core Idea

Instead of using a separate visited matrix, we can modify the grid in-place by changing visited '1's to '0's. This is the approach in your provided code.

**Why this works:**
- Once we've counted an island, we don't need those cells anymore
- Marking them as '0' prevents recounting
- Saves O(m × n) space

### Algorithm Flow

**Step-by-step execution with example:**

```
Initial grid:
[
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
```

**Iteration Process:**

1. **Start at (0,0)** - Found '1' → Island #1 detected, count = 1
   ```
   DFS marks all connected land:
   ["0","0","0","0","0"]
   ["0","0","0","0","0"]
   ["0","0","1","0","0"]
   ["0","0","0","1","1"]
   ```

2. **Continue scanning** - (2,2) found '1' → Island #2 detected, count = 2
   ```
   DFS marks:
   ["0","0","0","0","0"]
   ["0","0","0","0","0"]
   ["0","0","0","0","0"]
   ["0","0","0","1","1"]
   ```

3. **Continue scanning** - (3,3) found '1' → Island #3 detected, count = 3
   ```
   DFS marks:
   ["0","0","0","0","0"]
   ["0","0","0","0","0"]
   ["0","0","0","0","0"]
   ["0","0","0","0","0"]
   ```

**Final Answer:** 3 islands

### Optimized Implementation (Your Code)

```java
class Solution {
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        
        int count = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    count++;
                }
            }
        }
        return count;
    }
    
    private void dfs(char[][] grid, int i, int j) {
        // Base case: out of bounds or water
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length 
            || grid[i][j] == '0') {
            return;
        }
        
        // Mark current cell as visited by changing to '0'
        grid[i][j] = '0';
        
        // Explore all 4 directions
        dfs(grid, i + 1, j); // down
        dfs(grid, i - 1, j); // up
        dfs(grid, i, j + 1); // right
        dfs(grid, i, j - 1); // left
    }
}
```

**Time Complexity:** O(m × n) - Each cell is visited exactly once  
**Space Complexity:** O(m × n) - Recursion stack in worst case (entire grid is one island)

---

## Thinking Process & Strategy

### How to Approach This Problem

1. **Recognize the pattern:** This is a connected components problem in a graph
2. **Choose traversal method:** DFS or BFS both work equally well
3. **Handle visited cells:** Either use extra space or modify in-place
4. **Count islands:** Each DFS/BFS initiation represents a new island

### Why DFS Works Here

- **Recursive nature** naturally explores all connected cells
- **Simple implementation** with clear base cases
- **Efficient** for this grid-based problem
- Alternative: BFS using a queue works equally well

### Edge Cases to Consider

1. Empty grid → return 0
2. All water → return 0
3. All land → return 1
4. Single cell grid
5. Disconnected islands

---

## Alternative Approach: BFS (Breadth-First Search)

```java
class Solution {
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) return 0;
        
        int count = 0;
        int rows = grid.length;
        int cols = grid[0].length;
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == '1') {
                    count++;
                    bfs(grid, i, j);
                }
            }
        }
        return count;
    }
    
    private void bfs(char[][] grid, int i, int j) {
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{i, j});
        grid[i][j] = '0';
        
        int[][] directions = {{1,0}, {-1,0}, {0,1}, {0,-1}};
        
        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            int row = curr[0], col = curr[1];
            
            for (int[] dir : directions) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                
                if (newRow >= 0 && newRow < grid.length && 
                    newCol >= 0 && newCol < grid[0].length && 
                    grid[newRow][newCol] == '1') {
                    
                    queue.offer(new int[]{newRow, newCol});
                    grid[newRow][newCol] = '0';
                }
            }
        }
    }
}
```

---

## Key Takeaways

1. **Graph traversal on grids** - Treat 2D arrays as implicit graphs
2. **DFS vs BFS** - Both have O(m×n) time complexity; choose based on preference
3. **Space optimization** - In-place modification saves memory
4. **Connected components** - Count of DFS/BFS initiations = number of components

---

## Related Problems

- LeetCode 695: Max Area of Island
- LeetCode 463: Island Perimeter
- LeetCode 733: Flood Fill
- LeetCode 417: Pacific Atlantic Water Flow
- LeetCode 130: Surrounded Regions

---

## Practice Tips

1. Draw the grid and manually trace the algorithm
2. Understand the recursion call stack
3. Practice both DFS and BFS implementations
4. Consider when to use visited array vs in-place modification
5. Think about how this applies to other graph problems
