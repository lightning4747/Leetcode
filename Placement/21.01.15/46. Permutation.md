# LeetCode 46: Permutations

**Problem Link:** https://leetcode.com/problems/permutations/

## Problem Statement

Given an array `nums` of distinct integers, return all possible permutations. You can return the answer in any order.

**Example 1:**
```
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**Example 2:**
```
Input: nums = [0,1]
Output: [[0,1],[1,0]]
```

**Example 3:**
```
Input: nums = [1]
Output: [[1]]
```

**Constraints:**
- 1 <= nums.length <= 6
- -10 <= nums[i] <= 10
- All the integers of nums are unique.

---

## Core Idea & Intuition

The key insight is to think of building permutations as making a series of choices. At each step, we choose one unused number, add it to our current permutation, explore all possibilities from that point, then backtrack and try a different number.

Think of it like arranging people in a line for a photo: you pick the first person, then pick the second person from those remaining, then the third, and so on. Once you've tried all arrangements starting with person A in front, you backtrack and try person B in front instead.

**Visual Representation:**

![Permutations Tree](https://assets.leetcode.com/users/images/2f1c6f5f-d9c4-4c3e-9b0e-5c5e5c5e5c5e_1635789012.png)

---

## Solution Approaches

### Approach 1: Backtracking (Using Contains Check)

This is the approach shown in your code. It uses backtracking with a list to track the current permutation and checks if an element is already used.

**Algorithm Flow:**

```java
class Permutations {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrack(result, new ArrayList<>(), nums);
        return result;
    }

    private void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums) {
        // Base case: if current permutation is complete
        if (tempList.size() == nums.length) {
            result.add(new ArrayList<>(tempList));
        } else {
            for (int i = 0; i < nums.length; i++) {
                // Skip if element already used
                if (tempList.contains(nums[i])) {
                    continue;
                }
                // Choose
                tempList.add(nums[i]);
                // Explore
                backtrack(result, tempList, nums);
                // Unchoose (backtrack)
                tempList.remove(tempList.size() - 1);
            }
        }
    }
}
```

**Time Complexity:** O(n! × n²) - n! permutations, each requiring O(n) for contains check and O(n) for copying
**Space Complexity:** O(n! × n) - storing all permutations

**Drawback:** The `contains()` method is O(n), making this less efficient.

---

### Approach 2: Backtracking with Boolean Array (Optimized)

A more efficient approach uses a boolean array to track which elements have been used, reducing the lookup time from O(n) to O(1).

```java
class Permutations {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrack(result, new ArrayList<>(), nums, new boolean[nums.length]);
        return result;
    }

    private void backtrack(List<List<Integer>> result, List<Integer> tempList, 
                          int[] nums, boolean[] used) {
        // Base case: permutation complete
        if (tempList.size() == nums.length) {
            result.add(new ArrayList<>(tempList));
            return;
        }
        
        // Try each number
        for (int i = 0; i < nums.length; i++) {
            if (used[i]) continue; // Skip if already used
            
            // Choose
            used[i] = true;
            tempList.add(nums[i]);
            
            // Explore
            backtrack(result, tempList, nums, used);
            
            // Unchoose (backtrack)
            used[i] = false;
            tempList.remove(tempList.size() - 1);
        }
    }
}
```

**Time Complexity:** O(n! × n) - n! permutations, each requiring O(n) for copying
**Space Complexity:** O(n! × n) - for storing results

---

### Approach 3: Swap-based Backtracking (Most Efficient)

This approach swaps elements in place, avoiding the need for extra data structures to track used elements.

```java
class Permutations {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrack(result, nums, 0);
        return result;
    }

    private void backtrack(List<List<Integer>> result, int[] nums, int start) {
        // Base case: reached end of array
        if (start == nums.length) {
            List<Integer> permutation = new ArrayList<>();
            for (int num : nums) {
                permutation.add(num);
            }
            result.add(permutation);
            return;
        }
        
        // Try each element from start to end
        for (int i = start; i < nums.length; i++) {
            // Choose: swap current element to start position
            swap(nums, start, i);
            
            // Explore: permute remaining elements
            backtrack(result, nums, start + 1);
            
            // Unchoose: swap back (backtrack)
            swap(nums, start, i);
        }
    }
    
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

**Time Complexity:** O(n! × n)
**Space Complexity:** O(n! × n) for results, O(n) recursion stack

---

## Detailed Example Walkthrough

Let's trace through `nums = [1, 2, 3]` using the swap-based approach:

```
Initial: [1, 2, 3], start = 0

Step 1: start = 0
  - Swap(0, 0): [1, 2, 3] → recurse(start = 1)
    - Swap(1, 1): [1, 2, 3] → recurse(start = 2)
      - Swap(2, 2): [1, 2, 3] → recurse(start = 3)
        - Base case: Add [1, 2, 3] ✓
      - Swap back(2, 2): [1, 2, 3]
    - Swap(1, 2): [1, 3, 2] → recurse(start = 2)
      - Swap(2, 2): [1, 3, 2] → recurse(start = 3)
        - Base case: Add [1, 3, 2] ✓
      - Swap back(2, 2): [1, 3, 2]
    - Swap back(1, 2): [1, 2, 3]
  
  - Swap(0, 1): [2, 1, 3] → recurse(start = 1)
    - Swap(1, 1): [2, 1, 3] → recurse(start = 2)
      - Base case: Add [2, 1, 3] ✓
    - Swap(1, 2): [2, 3, 1] → recurse(start = 2)
      - Base case: Add [2, 3, 1] ✓
    - Swap back(1, 2): [2, 1, 3]
  - Swap back(0, 1): [1, 2, 3]
  
  - Swap(0, 2): [3, 2, 1] → recurse(start = 1)
    - Swap(1, 1): [3, 2, 1] → recurse(start = 2)
      - Base case: Add [3, 2, 1] ✓
    - Swap(1, 2): [3, 1, 2] → recurse(start = 2)
      - Base case: Add [3, 1, 2] ✓
    - Swap back(1, 2): [3, 2, 1]
  - Swap back(0, 2): [1, 2, 3]

Result: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,2,1], [3,1,2]]
```

---

## Thinking Process

**The Backtracking Template:**
1. **Choose**: Make a decision (add element to permutation)
2. **Explore**: Recursively explore from this state
3. **Unchoose**: Undo the decision (backtrack)

**Key Questions to Ask:**
- What is my base case? (When permutation length equals array length)
- What choices do I have at each step? (Any unused number)
- How do I track what's used? (Boolean array, contains check, or swap)
- How do I undo my choice? (Remove last element or swap back)

---

## Visual Decision Tree

For `[1, 2, 3]`:

```
                    []
         /          |          \
       [1]         [2]         [3]
      /  \        /  \        /  \
   [1,2][1,3]  [2,1][2,3]  [3,1][3,2]
     |    |      |    |      |    |
  [1,2,3][1,3,2][2,1,3][2,3,1][3,1,2][3,2,1]
```

Each path from root to leaf represents one complete permutation.

---

## Summary

| Approach | Time | Space | Pros | Cons |
|----------|------|-------|------|------|
| Contains Check | O(n! × n²) | O(n! × n) | Simple to understand | Inefficient contains() |
| Boolean Array | O(n! × n) | O(n! × n) | O(1) lookup | Extra space for tracking |
| Swap-based | O(n! × n) | O(n! × n) | In-place, clean | Modifies input array |

**Recommended:** Boolean array approach for interviews (good balance of efficiency and clarity).
