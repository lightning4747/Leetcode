# 199. Binary Tree Right Side View

**Difficulty:** Medium  
**Problem Link:** [LeetCode 199 - Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/)

---

## Problem Statement

Given the `root` of a binary tree, imagine yourself standing on the **right side** of it, return the values of the nodes you can see ordered from top to bottom.

---

## Examples

### Example 1:
```
Input: root = [1,2,3,null,5,null,4]
Output: [1,3,4]
```

**Visual Representation:**
```
       1            <--- 1 (visible)
      / \
     2   3          <--- 3 (visible, rightmost)
      \   \
       5   4        <--- 4 (visible, rightmost)
```

### Example 2:
```
Input: root = [1,2,3,4,null,null,null,5]
Output: [1,3,4,5]
```

**Visual Representation:**
```
       1            <--- 1 (visible)
      / \
     2   3          <--- 3 (visible, rightmost)
    /
   4                <--- 4 (visible, no right node at this level)
  /
 5                  <--- 5 (visible, no right node at this level)
```

### Example 3:
```
Input: root = [1,null,3]
Output: [1,3]
```

### Example 4:
```
Input: root = []
Output: []
```

---

## TreeNode Definition

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

---

## Solution Approaches

### Approach 1: BFS (Breadth-First Search) - Brute Force

**Time Complexity:** O(n)  
**Space Complexity:** O(w) where w is the maximum width of the tree

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) return result;
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();
                
                // The last node at each level is the rightmost
                if (i == levelSize - 1) {
                    result.add(node.val);
                }
                
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
        }
        
        return result;
    }
}
```

**Key Points:**
- Standard level-order traversal (BFS)
- At each level, capture the **last node** processed
- The last node at each level is the rightmost visible node
- Simple and intuitive approach

---

### Approach 2: BFS (Optimized) - Track Rightmost Only

**Time Complexity:** O(n)  
**Space Complexity:** O(w)

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) return result;
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            TreeNode rightmost = null;
            
            for (int i = 0; i < levelSize; i++) {
                rightmost = queue.poll();
                
                if (rightmost.left != null) queue.offer(rightmost.left);
                if (rightmost.right != null) queue.offer(rightmost.right);
            }
            
            // Add the last node of this level
            result.add(rightmost.val);
        }
        
        return result;
    }
}
```

**Key Points:**
- Similar to brute force but cleaner
- Keep updating `rightmost` variable; the last one is what we need
- Slightly more elegant code

---

### Approach 3: DFS (Depth-First Search) - Right-First Traversal ‚≠ê OPTIMAL

**Time Complexity:** O(n)  
**Space Complexity:** O(h) where h is the height of the tree

```java
class Solution {
    List<Integer> result = new ArrayList<>();
    
    public List<Integer> rightSideView(TreeNode root) {
        dfs(root, 0);
        return result;
    }
    
    private void dfs(TreeNode root, int depth) {
        if (root == null) return;
        
        // If this is the first node we're visiting at this depth
        if (depth == result.size()) {
            result.add(root.val);
        }
        
        // Visit right subtree first, then left
        dfs(root.right, depth + 1);
        dfs(root.left, depth + 1);
    }
}
```

**Key Points:**
- **Right-first DFS traversal** (root ‚Üí right ‚Üí left)
- First node encountered at each depth is the rightmost visible
- More space-efficient than BFS (uses recursion stack instead of queue)
- Elegant and efficient solution

---

### Approach 4: DFS with Depth Tracking (Alternative)

**Time Complexity:** O(n)  
**Space Complexity:** O(h)

```java
class Solution {
    List<Integer> list = new ArrayList<>();
    int depth = 0;
    
    public List<Integer> rightSideView(TreeNode root) {
        solve(root);
        return list;
    }
    
    private void solve(TreeNode root) {
        if (root == null) return;
        
        // First time visiting this depth level
        if (depth == list.size()) {
            list.add(root.val);
        }
        
        depth++;  // Go deeper
        solve(root.right);  // Visit right first
        solve(root.left);   // Then left
        depth--;  // Backtrack
    }
}
```

**Key Points:**
- Uses an instance variable to track depth
- Manually manages depth with increment/decrement
- Functionally identical to Approach 3
- Shows explicit backtracking

---

## Algorithm Flow with Example

Let's trace through **Example 1:** `root = [1,2,3,null,5,null,4]`

```
       1
      / \
     2   3
      \   \
       5   4
```

### BFS Approach - Step-by-Step:

**Initial State:**
```
Queue: [1]
Result: []
```

**Level 0:**
```
Level size: 1
Process node 1:
  - i = 0, levelSize - 1 = 0 ‚Üí This is the last node!
  - Add 1 to result
  - Add children: 2, 3
Queue: [2, 3]
Result: [1]
```

**Level 1:**
```
Level size: 2
Process node 2:
  - i = 0, not the last node
  - Add child: 5
Process node 3:
  - i = 1, levelSize - 1 = 1 ‚Üí This is the last node!
  - Add 3 to result
  - Add child: 4
Queue: [5, 4]
Result: [1, 3]
```

**Level 2:**
```
Level size: 2
Process node 5:
  - i = 0, not the last node
  - No children
Process node 4:
  - i = 1, levelSize - 1 = 1 ‚Üí This is the last node!
  - Add 4 to result
  - No children
Queue: []
Result: [1, 3, 4]
```

**Final Output:** `[1, 3, 4]`

---

### DFS Approach - Step-by-Step:

**Call Stack Visualization:**

```
dfs(1, depth=0)
‚îú‚îÄ‚îÄ depth(0) == result.size(0) ‚Üí Add 1
‚îÇ   Result: [1]
‚îú‚îÄ‚îÄ dfs(3, depth=1)  // RIGHT FIRST!
‚îÇ   ‚îú‚îÄ‚îÄ depth(1) == result.size(1) ‚Üí Add 3
‚îÇ   ‚îÇ   Result: [1, 3]
‚îÇ   ‚îú‚îÄ‚îÄ dfs(null, depth=2) ‚Üí return
‚îÇ   ‚îî‚îÄ‚îÄ dfs(4, depth=2)
‚îÇ       ‚îú‚îÄ‚îÄ depth(2) == result.size(2) ‚Üí Add 4
‚îÇ       ‚îÇ   Result: [1, 3, 4]
‚îÇ       ‚îú‚îÄ‚îÄ dfs(null, depth=3) ‚Üí return
‚îÇ       ‚îî‚îÄ‚îÄ dfs(null, depth=3) ‚Üí return
‚îî‚îÄ‚îÄ dfs(2, depth=1)  // LEFT SECOND
    ‚îú‚îÄ‚îÄ depth(1) == result.size(3) ‚Üí FALSE! (1 != 3)
    ‚îÇ   Don't add 2 (already have a node at depth 1)
    ‚îú‚îÄ‚îÄ dfs(null, depth=2) ‚Üí return
    ‚îî‚îÄ‚îÄ dfs(5, depth=2)
        ‚îú‚îÄ‚îÄ depth(2) == result.size(3) ‚Üí FALSE! (2 != 3)
        ‚îÇ   Don't add 5 (already have a node at depth 2)
        ‚îú‚îÄ‚îÄ dfs(null, depth=3) ‚Üí return
        ‚îî‚îÄ‚îÄ dfs(null, depth=3) ‚Üí return
```

**Key Insight:** By visiting **right first**, we ensure the first node we encounter at each depth is the rightmost visible node!

**Final Output:** `[1, 3, 4]`

---

### Example 2 Detailed Trace:

**Input:** `root = [1,2,3,4,null,null,null,5]`

```
       1
      / \
     2   3
    /
   4
  /
 5
```

**DFS Traversal (Right-First):**

```
dfs(1, 0) ‚Üí Add 1, Result: [1]
  dfs(3, 1) ‚Üí Add 3, Result: [1, 3]
    dfs(null, 2) ‚Üí return
    dfs(null, 2) ‚Üí return
  dfs(2, 1) ‚Üí Skip (depth 1 already has 3)
    dfs(null, 2) ‚Üí return
    dfs(4, 2) ‚Üí Add 4, Result: [1, 3, 4]
      dfs(null, 3) ‚Üí return
      dfs(5, 3) ‚Üí Add 5, Result: [1, 3, 4, 5]
        dfs(null, 4) ‚Üí return
        dfs(null, 4) ‚Üí return
```

**Output:** `[1, 3, 4, 5]`

Notice that even though 2 is at depth 1, we don't add it because we already added 3 (the rightmost at depth 1). Similarly for node 5 at depth 3 - it's the only node at that depth, so it's visible from the right!

---

## Core Idea & Thinking Process

### Intuition

**What does "right side view" mean?**
- Stand on the right side of the tree
- At each level, you can see the **rightmost node**
- Some levels might have only left nodes visible (if no right nodes exist)

### Key Insights

**Two Mental Models:**

1. **Level-Order Thinking (BFS):**
   - Process the tree level by level
   - At each level, the last node is what we see from the right
   - Natural and intuitive

2. **Depth-First Thinking (DFS):**
   - Visit right subtree before left subtree
   - The **first node** we encounter at each depth is the rightmost
   - More elegant and space-efficient

### Why DFS Right-First Works?

The brilliant insight:
```
If we visit RIGHT before LEFT, 
the FIRST node at each depth is the RIGHTMOST!
```

**Example:**
```
       1
      / \
     2   3
      \
       5
```

- Depth 0: First visit ‚Üí node 1 ‚úì
- Depth 1: First visit ‚Üí node 3 (from right) ‚úì
- Depth 2: First visit ‚Üí node 5 (from right subtree) ‚úì

Node 2 is visited at depth 1, but we already have node 3, so we skip it!

### The "First Node at Depth" Pattern

```java
if (depth == result.size()) {
    result.add(root.val);
}
```

This condition means:
- `result.size()` tells us how many depths we've seen so far
- If `depth == result.size()`, this is our first node at this depth
- Add it to result (it's the rightmost because we visit right first!)
- Subsequent nodes at the same depth are ignored

---

## Visual Diagram

![Binary Tree Right Side View](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)

### Right Side View Visualization:

```
       1  ‚Üê‚îÄ‚îÄ Level 0: See node 1
      / \
     2   3  ‚Üê‚îÄ‚îÄ Level 1: See node 3 (rightmost)
      \   \
       5   4  ‚Üê‚îÄ‚îÄ Level 2: See node 4 (rightmost)

View from right: [1, 3, 4]
```

### Another Example with Left-Heavy Tree:

```
       1  ‚Üê‚îÄ‚îÄ See 1
      / \
     2   3  ‚Üê‚îÄ‚îÄ See 3
    /
   4  ‚Üê‚îÄ‚îÄ See 4 (no nodes to the right at this level)
  /
 5  ‚Üê‚îÄ‚îÄ See 5 (no nodes to the right at this level)

View from right: [1, 3, 4, 5]
```

---

## Complexity Analysis

### BFS Approach

| Metric | Complexity | Explanation |
|--------|-----------|-------------|
| **Time** | O(n) | Visit each node exactly once |
| **Space** | O(w) | Queue holds at most one level; w = max width of tree |

### DFS Approach

| Metric | Complexity | Explanation |
|--------|-----------|-------------|
| **Time** | O(n) | Visit each node exactly once |
| **Space** | O(h) | Recursion stack depth = tree height |

### Space Complexity Comparison

For different tree shapes:

**Balanced Tree:** h ‚âà log(n), w ‚âà n/2
- BFS: O(n/2) = O(n)
- DFS: O(log n)
- **Winner: DFS** ‚úì

**Skewed Tree:** h ‚âà n, w ‚âà 1
- BFS: O(1)
- DFS: O(n)
- **Winner: BFS** ‚úì

**In Practice:** DFS is generally preferred for its elegance and better average-case space complexity.

---

## Comparison: BFS vs DFS

| Aspect | BFS | DFS (Right-First) |
|--------|-----|-------------------|
| **Approach** | Level-order, track last node | Pre-order, visit right first |
| **Space** | O(w) - queue | O(h) - recursion stack |
| **Intuition** | "Last node of each level" | "First node at each depth" |
| **Code Length** | Moderate | Short and elegant |
| **Best For** | Very skewed trees | Balanced trees |
| **Interview Preference** | Good starting point | Shows deeper understanding |

---

## Common Patterns & Variations

### Pattern Recognition

This problem uses the **"First/Last at Each Level"** pattern:

**Related Problems:**
- Left Side View ‚Üí Visit left first in DFS
- Top View ‚Üí Track horizontal distance
- Bottom View ‚Üí Track horizontal distance, keep last
- Vertical Order ‚Üí Group by column

### Variations

**1. Left Side View:**
```java
// Just swap the order!
dfs(root.left, depth + 1);   // LEFT FIRST
dfs(root.right, depth + 1);  // RIGHT SECOND
```

**2. Both Sides View:**
```java
// Combine both!
List<Integer> leftView = getLeftView(root);
List<Integer> rightView = getRightView(root);
```

---

## Key Takeaways

1. **BFS is intuitive** - process level by level, take the last node
2. **DFS is elegant** - visit right first, take the first node at each depth
3. **"First at depth" check** - `if (depth == result.size())` is crucial
4. **Order matters** - visiting right before left makes DFS work
5. **Space trade-off** - DFS usually better for balanced trees
6. **Pattern recognition** - applicable to many tree view problems

---

## Interview Tips

**When asked this problem:**

1. **Clarify edge cases:**
   - Empty tree? ‚Üí Return empty list
   - Single node? ‚Üí Return [node.val]
   - All left nodes? ‚Üí Still visible from right!

2. **Start with BFS:**
   ```
   "We can do level-order traversal and capture 
   the last node at each level"
   ```

3. **Optimize to DFS:**
   ```
   "For better space complexity, we can use DFS 
   visiting right subtree first"
   ```

4. **Explain the key insight:**
   ```
   "By visiting right first, the first node we 
   encounter at each depth is the rightmost visible node"
   ```

5. **Discuss complexity:**
   - BFS: O(n) time, O(w) space
   - DFS: O(n) time, O(h) space
   - DFS better for balanced trees

**Follow-up questions:**
- **Q:** Can you get the left side view?  
  **A:** Yes, just visit left before right in DFS

- **Q:** What if we want both left and right views?  
  **A:** Run both algorithms or modify BFS to track both

- **Q:** How would you handle a very wide tree?  
  **A:** DFS would be better (less space)

- **Q:** What about a very deep, narrow tree?  
  **A:** BFS might be better (less recursion depth risk)

---

## Summary

**Problem Essence:** Find the rightmost visible node at each level

**Best Solution:** DFS with right-first traversal
- ‚úÖ Elegant and concise
- ‚úÖ Space-efficient for balanced trees
- ‚úÖ Easy to modify for variations

**Key Pattern:** "First node at each depth" when visiting in a specific order

**Remember:** The order of recursion (right then left) is what makes the magic happen! üéØ
