# LeetCode 102: Binary Tree Level Order Traversal

## Problem Information

**Difficulty**: Medium  
**Problem Number**: 102  
**Problem Link**: [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)

---

## Problem Statement

Given the `root` of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).

### Examples

**Example 1:**
```
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
```

**Example 2:**
```
Input: root = [1]
Output: [[1]]
```

**Example 3:**
```
Input: root = []
Output: []
```

### Constraints
- The number of nodes in the tree is in the range `[0, 2000]`
- `-1000 <= Node.val <= 1000`

---

## Visual Representation

```
Example 1 Tree Structure:
        3
       / \
      9   20
         /  \
        15   7

Level 0: [3]
Level 1: [9, 20]
Level 2: [15, 7]

Output: [[3], [9, 20], [15, 7]]
```

---

## Core Idea and Intuition

### The Problem
We need to visit all nodes level by level, from left to right, and group them by their level. This is fundamentally different from depth-first traversals (inorder, preorder, postorder) because we process nodes horizontally across levels rather than vertically down branches.

### Key Insight
**Level Order Traversal = Breadth-First Search (BFS)**

The critical observation is that we need to:
1. Process all nodes at the current level before moving to the next level
2. Group nodes by their depth/level in the tree
3. Maintain left-to-right order within each level

### Why This Problem is Important
Level order traversal is a fundamental tree operation used in:
- Finding shortest paths in unweighted trees
- Serialization/deserialization of trees
- Finding level-wise properties (width, sum, average)
- Level-wise tree modifications

---

## Approach 1: BFS using Queue (Standard Iterative Solution)

### Intuition
Think of the tree like a multi-story building. We want to visit each floor completely before going to the next floor. A queue is perfect for this because:
- It maintains FIFO (First In First Out) order
- We process nodes in the order we discover them
- We can easily separate levels by tracking queue size

### Algorithm Flow

**Step-by-step process:**

1. **Initialize**: Create a queue and add the root node
2. **Level Processing**: For each level:
   - Record the current queue size (number of nodes at this level)
   - Process exactly that many nodes
   - Add children of processed nodes to queue (for next level)
3. **Result Building**: Collect processed nodes into a list for current level
4. **Repeat**: Continue until queue is empty

### Detailed Example Walkthrough

Let's trace through Example 1: `root = [3,9,20,null,null,15,7]`

```
Initial State:
        3
       / \
      9   20
         /  \
        15   7

Queue: [3]
Result: []
```

**Iteration 1 (Level 0):**
```
Queue size: 1 (process 1 node)
Current level: []

Process node 3:
  - Add 3 to current level: [3]
  - Add children 9 and 20 to queue
  
Queue after: [9, 20]
Current level: [3]
Result after: [[3]]
```

**Iteration 2 (Level 1):**
```
Queue size: 2 (process 2 nodes)
Current level: []

Process node 9:
  - Add 9 to current level: [9]
  - No children to add
  
Process node 20:
  - Add 20 to current level: [9, 20]
  - Add children 15 and 7 to queue
  
Queue after: [15, 7]
Current level: [9, 20]
Result after: [[3], [9, 20]]
```

**Iteration 3 (Level 2):**
```
Queue size: 2 (process 2 nodes)
Current level: []

Process node 15:
  - Add 15 to current level: [15]
  - No children to add
  
Process node 7:
  - Add 7 to current level: [15, 7]
  - No children to add
  
Queue after: []
Current level: [15, 7]
Result after: [[3], [9, 20], [15, 7]]
```

**Final Result:** `[[3], [9, 20], [15, 7]]`

### Java Implementation

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        // Result list to store all levels
        List<List<Integer>> ans = new ArrayList<>();
        
        // Queue for BFS traversal
        Queue<TreeNode> q = new LinkedList<>();
        
        // Edge case: empty tree
        if (root == null) return ans;
        
        // Start with root node
        q.offer(root);
        
        // Process level by level
        while (!q.isEmpty()) {
            // Current level's nodes
            List<Integer> row = new ArrayList<>();
            
            // Number of nodes at current level
            int n = q.size();
            
            // Process all nodes at current level
            for (int i = 0; i < n; i++) {
                TreeNode front = q.poll();
                row.add(front.val);
                
                // Add children for next level
                if (front.left != null) q.offer(front.left);
                if (front.right != null) q.offer(front.right);
            }
            
            // Add current level to result
            ans.add(row);
        }
        
        return ans;
    }
}
```

### Complexity Analysis

**Time Complexity**: O(n)
- We visit each node exactly once
- Each node is added to and removed from the queue once
- n = total number of nodes in the tree

**Space Complexity**: O(w)
- Queue can contain at most all nodes at the widest level
- w = maximum width of the tree
- In worst case (complete binary tree), w can be n/2, so O(n)
- Result space is O(n) but not counted as auxiliary space

---

## Approach 2: DFS using Recursion (Optimized Space)

### Intuition
While level order traversal is naturally a BFS problem, we can also solve it using DFS with a clever trick:
- Track the current level/depth during recursion
- Use the level as an index to add nodes to the correct level list
- The recursive call stack implicitly handles the traversal

This approach is less intuitive but more space-efficient in some cases.

### Algorithm Flow

**Key Idea**: Pass the current level as a parameter during recursion

1. **Recursive Call**: For each node, pass its level/depth
2. **List Management**: If visiting a level for the first time, create a new list
3. **Add Node**: Add current node's value to its level's list
4. **Recurse**: Visit left child (level + 1), then right child (level + 1)

### Detailed Example Walkthrough

Using the same tree: `root = [3,9,20,null,null,15,7]`

```
        3        (level 0)
       / \
      9   20     (level 1)
         /  \
        15   7   (level 2)
```

**Recursion Trace:**

```
Call 1: helper(3, level=0, ans=[])
  - ans.size() = 0, level = 0, so add new list: ans = [[]]
  - Add 3 to ans[0]: ans = [[3]]
  - Recurse left: helper(9, level=1, ans)
  
    Call 2: helper(9, level=1, ans=[[3]])
      - ans.size() = 1, level = 1, so add new list: ans = [[3], []]
      - Add 9 to ans[1]: ans = [[3], [9]]
      - Recurse left: helper(null, level=2, ans) → return
      - Recurse right: helper(null, level=2, ans) → return
    
  - Recurse right: helper(20, level=1, ans)
  
    Call 3: helper(20, level=1, ans=[[3], [9]])
      - ans.size() = 2, level = 1, list exists
      - Add 20 to ans[1]: ans = [[3], [9, 20]]
      - Recurse left: helper(15, level=2, ans)
      
        Call 4: helper(15, level=2, ans=[[3], [9, 20]])
          - ans.size() = 2, level = 2, so add new list: ans = [[3], [9, 20], []]
          - Add 15 to ans[2]: ans = [[3], [9, 20], [15]]
          - Recurse left: helper(null, level=3, ans) → return
          - Recurse right: helper(null, level=3, ans) → return
      
      - Recurse right: helper(7, level=2, ans)
      
        Call 5: helper(7, level=2, ans=[[3], [9, 20], [15]])
          - ans.size() = 3, level = 2, list exists
          - Add 7 to ans[2]: ans = [[3], [9, 20], [15, 7]]
          - Recurse left: helper(null, level=3, ans) → return
          - Recurse right: helper(null, level=3, ans) → return
```

**Final Result:** `[[3], [9, 20], [15, 7]]`

### Java Implementation

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        helper(root, 0, ans);
        return ans;
    }
    
    private void helper(TreeNode root, int level, List<List<Integer>> ans) {
        // Base case: null node
        if (root == null) return;
        
        // If this is the first node at this level, create new list
        if (level == ans.size()) {
            ans.add(new ArrayList<>());
        }
        
        // Add current node's value to its level
        ans.get(level).add(root.val);
        
        // Recurse to left and right children with incremented level
        helper(root.left, level + 1, ans);
        helper(root.right, level + 1, ans);
    }
}
```

### Complexity Analysis

**Time Complexity**: O(n)
- We visit each node exactly once
- Each node is processed in constant time
- n = total number of nodes

**Space Complexity**: O(h)
- Recursion stack depth is the height of the tree
- h = height of the tree
- Best case (balanced tree): O(log n)
- Worst case (skewed tree): O(n)
- Note: This excludes the result space

---

## Comparison: BFS vs DFS Approach

| Aspect | BFS (Queue) | DFS (Recursion) |
|--------|-------------|-----------------|
| **Intuition** | Natural for level order | Less intuitive |
| **Code Clarity** | Very clear | Requires level tracking |
| **Space (Balanced Tree)** | O(n/2) queue | O(log n) stack |
| **Space (Skewed Tree)** | O(1) queue | O(n) stack |
| **Best For** | Wide trees | Deep trees |
| **Iteration Order** | Level by level | Depth first, organized by level |

---

## Key Takeaways

### When to Use Each Approach

**Use BFS (Queue) when:**
- You need a straightforward, easy-to-understand solution
- The tree is likely to be very deep (to avoid stack overflow)
- You're comfortable with iterative solutions
- **This is the standard and most commonly used approach**

**Use DFS (Recursion) when:**
- Memory is constrained and tree is balanced
- You prefer recursive thinking
- The problem has other recursive components

### Common Mistakes to Avoid

1. **Not capturing queue size before the loop**: Processing nodes level by level requires knowing how many nodes are at the current level
   ```java
   // Wrong
   while (!q.isEmpty()) {
       for (int i = 0; i < q.size(); i++) { // q.size() changes!
   
   // Correct
   while (!q.isEmpty()) {
       int n = q.size();
       for (int i = 0; i < n; i++) {
   ```

2. **Forgetting null checks**: Always check if children exist before adding to queue
   ```java
   if (node.left != null) q.offer(node.left);
   if (node.right != null) q.offer(node.right);
   ```

3. **In DFS approach, not checking if list exists**: Always check `if (level == ans.size())` before accessing

---

## Related Problems

Once you master this problem, try these variations:

1. **LeetCode 107**: Binary Tree Level Order Traversal II (bottom-up)
2. **LeetCode 103**: Binary Tree Zigzag Level Order Traversal
3. **LeetCode 199**: Binary Tree Right Side View
4. **LeetCode 515**: Find Largest Value in Each Tree Row
5. **LeetCode 637**: Average of Levels in Binary Tree

---

## Practice Tips

1. **Visualize**: Always draw the tree and trace through the algorithm step by step
2. **Track Queue State**: Write down queue contents after each operation
3. **Level Separation**: The key insight is using queue size to separate levels
4. **Master BFS First**: Get comfortable with the queue-based approach before trying DFS

---

## Summary

**Problem Essence**: Group tree nodes by their level (depth) and return them left to right.

**Core Technique**: Breadth-First Search using a queue, processing one level at a time.

**Key Insight**: Use queue size to know when one level ends and the next begins.

**Best Solution**: BFS with queue is the standard and most intuitive approach for level order traversal.
