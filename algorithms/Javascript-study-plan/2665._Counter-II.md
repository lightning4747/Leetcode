# Counter II (LeetCode 2665)

This problem tests one of the most fundamental and powerful features in JavaScript: **closures**. The goal is to build a counter that remembers its internal state across function calls.

---

## Problem Summary

You must write a function `createCounter(init)` that returns an object with three functions:

* `increment()` → increases the stored value by 1 and returns it.
* `decrement()` → decreases the stored value by 1 and returns it.
* `reset()` → resets the stored value back to the original `init` and returns it.

Each call should modify the *same* internal value, not create a new one.

---

## Core Concept: Closures

JavaScript functions don’t just carry their code; they also carry the **environment** where they were created. This allows inner functions to access variables from an outer function even after that outer function has finished executing.

This environment attached to the function is called a **closure**.

In this problem:

* `createCounter` creates a private variable (`count`) that stores the current number.
* The returned `increment`, `decrement`, and `reset` functions *all share access* to that variable.
* Calling these functions updates the shared variable rather than making new ones.

The counter works because closures preserve the state.

---

## Implementation Logic

We keep two values:

* **`init`** → the original initial value, used by `reset()`.
* **`count`** → the live value that gets updated with each call.

The returned object exposes three methods that modify and return `count`.

```js
var createCounter = function (init) {
    let count = init;

    return {
        increment() {
            return ++count;
        },
        decrement() {
            return --count;
        },
        reset() {
            count = init;
            return count;
        }
    };
};
```

---

## Why This Method Works

* `count` stays alive due to the closure.
* Each method updates the same `count`, not a copy.
* `reset()` uses the preserved `init` value.
* No global variables, no classes, no hacks — just closures.

This pattern shows up everywhere in JavaScript: memoization, rate limiting, debouncing, and async code often rely on closures to preserve state between function calls.

---

## Example Usage

```js
const counter = createCounter(5);
counter.increment(); // 6
counter.reset(); // 5
counter.decrement(); // 4
```

The same internal `count` is evolving over time.

---

## Key Takeaway

This problem isn't about counters. It's about understanding how JavaScript stores state over time using closures. Mastering this concept prepares you for more complex patterns in real applications and later JavaScript problems.
