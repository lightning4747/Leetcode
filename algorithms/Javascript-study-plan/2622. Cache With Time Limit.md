# 2622.Time-Limited Cache 

## Problem Statement

Design a class `TimeLimitedCache` that stores key–value pairs **with expiration times**. Each key should be accessible only until its expiration timestamp.

Your class must support three operations:

### `set(key, value, duration)`

Stores the key with the given value and marks it as valid for `duration` milliseconds.
Returns:

* `true` if the key **already existed** and **had not expired**
* `false` otherwise

### `get(key)`

Returns:

* the value if the key exists **and has not expired**
* `-1` otherwise
  (If expired, the key should be removed automatically)

### `count()`

Returns the number of **currently active (non-expired)** keys in the cache.

---

## Core Idea

The cache behaves like a normal `Map` but each key carries an expiration timestamp.
When:

* **setting**, we overwrite old values but check if it was alive before
* **getting**, we verify expiration and delete if needed
* **counting**, we clean up expired keys and count the rest

Using `Date.now()` gives us the current time in milliseconds.

---

## Clean & Correct Implementation

```js
var TimeLimitedCache = function() {
    this.store = new Map();
};

/** 
 * @param {number} key
 * @param {number} value
 * @param {number} duration
 * @return {boolean}
 */
TimeLimitedCache.prototype.set = function(key, value, duration) {
    const now = Date.now();
    const expiresAt = now + duration;

    const existing = this.store.get(key);
    const isAlive = existing && existing.expiresAt > now;

    this.store.set(key, { value, expiresAt });
    return Boolean(isAlive);
};

/** 
 * @param {number} key
 * @return {number}
 */
TimeLimitedCache.prototype.get = function(key) {
    const entry = this.store.get(key);
    const now = Date.now();

    if (!entry) return -1;

    if (entry.expiresAt <= now) {
        this.store.delete(key);
        return -1;
    }

    return entry.value;
};

/** 
 * @return {number}
 */
TimeLimitedCache.prototype.count = function() {
    const now = Date.now();
    let alive = 0;

    for (const [key, { expiresAt }] of this.store.entries()) {
        if (expiresAt > now) {
            alive++;
        } else {
            this.store.delete(key);
        }
    }

    return alive;
};
```

---

## How It Works (Step-by-Step)

### Setting a Key

* Compute expiration time: `now + duration`
* Check if the key exists and hasn't expired → determines return value
* Update the key with latest value and timestamp

### Getting a Key

* If the key doesn’t exist → return `-1`
* If expired → delete & return `-1`
* Otherwise → return value

### Counting Valid Keys

* Iterate through the `Map`
* Remove expired entries
* Count all valid ones

This ensures the cache is always up-to-date and never stores dead keys longer than necessary.

---

## Example Usage

```js
const cache = new TimeLimitedCache();
cache.set(1, 42, 1000);  // false (new key)
cache.get(1);            // 42
cache.count();           // 1
```

---

## Key Takeaways

* Use `Date.now()` to track expiration with millisecond precision
* Store entries as `{ value, expiresAt }` for clarity
* Clean expired values proactively during operations
* `set()` only returns true if you're overwriting a **still-valid** key

---

I can extend this approach later to build in-memory caches, rate limiters, or TTL-based systems.
