#2715. Timeout Cancellation

I'm mixing **two different timeouts** in your head — and that’s exactly where people usually trip. Let’s break it cleanly, because the problem is basically a duel between *fn’s timer* and *cancelFn’s timer*.

Think of it like this: you’ve got a bomb (fn) set to explode after **t ms**. You also have a separate tiny robot (cancelFn) scheduled to run after **cancelTimeMs**. If the robot reaches the bomb before it explodes, it defuses it. If it reaches too late, boom — fn runs.

Simple idea. Two clocks. Whichever fires first decides the outcome.

The whole point of this problem is:
You must manually implement a way to **cancel a scheduled function** before it runs. JavaScript’s `setTimeout` gives you the ability to schedule something **and** the power to cancel it using `clearTimeout`. That’s the entire trick.

Your job is to package that power into a reusable wrapper.

Let’s walk through purpose + solution mentally, then I’ll show a clean implementation.

---

### **Purpose**

This pattern shows up everywhere in real-world async logic:

• Cancel API requests if user navigates away
• Cancel expensive computations if they’re no longer needed
• Cancel loading screens if the response already arrived
• Prevent race conditions in UI events

Basically:
**You avoid wasting time and resources on something that's already irrelevant.**

And you — as always — must learn to think before acting. If you don’t cancel at the right moment, JavaScript won’t save you; it’ll execute fn like a blind machine.

---

### **How to Solve It (Conceptually)**

1. Schedule `fn(...args)` using `setTimeout`, store the timeout ID.
2. Return a cancel function.
3. That cancel function must:

   * call `clearTimeout`
   * ensure `fn` never runs if cancellation happens early
4. Another `setTimeout` (given by LeetCode) will call your `cancelFn` after `cancelTimeMs`.

Essentially:

```
(fn timer) ------------- t ms -> execute fn

(cancelFn timer) ---- cancelTimeMs ms -> cancelFn()
```

If cancelFn runs first → fn is cancelled.
If fn runs first → cancelFn does nothing because fn already executed.

---

### **Clean Implementation**

Here’s the working solution you should understand:

```js
/**
 * @param {Function} fn
 * @param {Array} args
 * @param {number} t
 * @return {Function}
 */
var cancellable = function(fn, args, t) {
    // schedule fn to execute after t milliseconds
    const timerId = setTimeout(() => {
        fn(...args);
    }, t);

    // return the cancel function
    const cancelFn = function() {
        clearTimeout(timerId);
    };

    return cancelFn;
};
```

---

### **Why it works**

Because `setTimeout` returns an ID that gives you the power to erase its future.
You’re literally deleting the planned execution event before it happens.
Just be cautious: if you call `cancelFn` **after** fn already ran, it’s useless — damage is done.

That’s the whole game.

---

If you want, we can walk through a concrete timeline example to cement it.
