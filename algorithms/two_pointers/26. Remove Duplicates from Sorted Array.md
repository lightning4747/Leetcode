# 26. Remove Duplicates from Sorted Array

## Problem Statement
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.

Consider the number of unique elements in nums to be k​​​​​​​​​​​​​​. After removing duplicates, return the number of unique elements k.

The first k elements of nums should contain the unique numbers in sorted order. The remaining elements beyond index k - 1 can be ignored.
**Example:**
```
Input: nums = [1,1,2,2,3]
Output: 3
Explanation: Your function should return length = 3, with the first three elements being 1, 2, and 3.
```

---

## Solution

```python
class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        i = 0
        for j in range(1, len(nums)):
            if nums[i] != nums[j]:
                i += 1
                nums[i] = nums[j]
                
        return i + 1
```

---

## Approach: Two Pointers

### Core Idea
Use two pointers:
- **`i`**: Tracks the position where the next unique element should be placed
- **`j`**: Scans through the array to find unique elements

### Algorithm Steps

1. **Initialize** `i = 0` (first element is always unique)
2. **Scan** with `j` from index 1 to end
3. **When we find a new unique element** (`nums[j] != nums[i]`):
   - Move `i` forward: `i += 1`
   - Place the unique element at position `i`: `nums[i] = nums[j]`
4. **Return** `i + 1` (count of unique elements)

### Why This Works

Since the array is **sorted**, all duplicates are adjacent. We can:
- Keep the first occurrence of each value
- Overwrite subsequent positions with new unique values
- The order is preserved because we scan left to right

---

## Step-by-Step Example

**Input:** `nums = [1, 1, 2, 2, 3]`

| Step | i | j | nums[i] | nums[j] | Action | Array State |
|------|---|---|---------|---------|--------|-------------|
| Init | 0 | 1 | 1 | 1 | Skip (same) | `[1,1,2,2,3]` |
| 1 | 0 | 2 | 1 | 2 | i=1, nums[1]=2 | `[1,2,2,2,3]` |
| 2 | 1 | 3 | 2 | 2 | Skip (same) | `[1,2,2,2,3]` |
| 3 | 1 | 4 | 2 | 3 | i=2, nums[2]=3 | `[1,2,3,2,3]` |
| End | 2 | - | - | - | Return 2+1=3 | `[1,2,3,_,_]` |

**Result:** First 3 elements `[1,2,3]` are unique, return `3`

---

## Key Concepts Learned

### 1. **In-Place Array Modification**
- We don't create a new array
- We overwrite duplicates with unique values
- Space complexity: O(1) - only using two pointers

### 2. **Two Pointers Pattern**
- **Slow pointer (`i`)**: Tracks valid/processed elements
- **Fast pointer (`j`)**: Explores/scans ahead
- Common pattern for array problems requiring O(n) time

### 3. **Index vs Count**
- `i` is a 0-based index
- To get count of elements, we return `i + 1`
- If `i = 2`, we have elements at indices 0, 1, 2 → 3 total elements

### 4. **Sorted Array Advantage**
- Duplicates are adjacent, so we only compare consecutive elements
- No need to check the entire array for each element
- This enables O(n) time complexity

### 5. **Why `for` Loop Works Here**
- Unlike "Two Sum II", we don't need conditional movement of both pointers
- `j` always moves forward (scanning)
- Only `i` moves conditionally (when we find unique elements)
- `for` loop is perfect when one pointer moves unconditionally

---

## Complexity Analysis

- **Time Complexity:** O(n) - single pass through array
- **Space Complexity:** O(1) - only two pointer variables

---

## Common Mistakes to Avoid

❌ **Creating a new array** - violates in-place requirement
❌ **Returning `i` instead of `i + 1`** - off-by-one error
❌ **Not modifying the original array** - problem requires in-place modification
❌ **Starting `j` from 0** - unnecessary comparison at first element

---

## Related Problems

- Remove Element
- Move Zeroes
- Remove Duplicates from Sorted Array II (allow duplicates twice)

---

## When to Use This Pattern

Use the **slow/fast pointer** approach when:
- Array/string modification in-place is required
- Need O(1) extra space
- Processing elements based on certain conditions
- One pointer tracks "valid" position, other explores
